* Tanuki
** Backend Rewrite
*** Clean Architecture design
**** use dependency injection to connect parts together
***** https://crates.io/crates/shaku (compile-time IoC)
***** https://crates.io/crates/coi (compile-time IoC)
***** consider if writing one from scratch (a la =get_it=) would be adequate
**** use TDD and mocking to develop from the inside out
***** https://crates.io/crates/mockall
**** entities
***** asset
***** location (label, gps, etc)
***** search result (location, media type, filename, date)
**** use cases
***** count all assets
***** import asset
***** update asset details
***** get all locations
***** get all years
***** get all tags
***** search for assets
***** get asset by checksum
***** fetch asset details
***** backup the database (an automatic function?)
****** use repository to invoke backup/restore functions
****** data source for record database invokes the db functions
**** repositories
***** record database
***** blob store
*** Thumbnail Serving Strategy
**** capture the image/video dimensions during import, save to asset record
***** a larger asset record in CBOR format is ~260 bytes, a few more bytes is okay
***** in PouchDB, each record takes almost exactly 1 kilobyte
***** use =u32= for each dimension (should be more than enough)
**** on import, ensure asset identifier ends with correct media type extension
***** if provided filename does not end in the correct extension, append it
****** use the provided media type to know what extension to add
***** this ensures correct guessing of media type when making thumbnails
***** n.b. all thumbnails and previews are image/jpeg anyway so this is not necessary
***** if, someday, the provided media type is "unknown", then use mime sniffer
***** c.f. https://developer.mozilla.org/en-US/docs/Mozilla/How_Mozilla_determines_MIME_Types
***** c.f. https://github.com/flier/rust-mime-sniffer
**** the frontend can use the image dimensions to compute the aspect ratio
**** with the aspect ratio, frontend can request images of the desired size
**** frontend can ask for images that are N pixels high or M pixels wide, or whatever
***** by leaving one dimension maxed out, the image aspect ratio will be maintained
**** as long as client keeps asking for the same basic size, backend can cache them
**** when generating thumbnail, always use jpeg format so content type is =image/jpeg=
*** DONE write an export script for the old database
**** stand-alone script that reads the database and writes out json
*** DONE write an import binary for the new database
**** stand-alone binary that reads json and populates new database
**** read the image dimensions to insert into asset record
*** DONE test database migration on development system
*** DONE set up docker build for rust code and healthcheck
**** c.f. https://github.com/mastertinner/healthcheck
***** it has been updated since the copy in zorigami
**** look at https://github.com/bencord0/docker-healthcheck/
*** TODO perform migration on production system
**** stop current docker container
**** use export script to get dump of current database
**** use import binary to create new database
**** backup the database files somewhere safe
**** deploy new docker container with new backend
**** find and remove the video thumbnails (there will be a =.mov= and =.jpg= with the same id)
***** just use shell commands and find them, there aren't that many
*** TODO update the provisioning Ansible tanuki deployment
*** TODO remove mujina from mac mini
*** TODO move =test/fixtures= under =tests=
*** TODO remove JavaScript code from =src= and =test=
*** TODO remove Node modules related to backend
*** TODO remove remaining old backend files
**** =public/schema.graphql=
**** =views/=
*** TODO update remaining Node modules for the time being
** Video metadata support
*** https://github.com/alfg/mp4rs (MIT)
**** creation time is in =moov.mvhd.creation_time=
**** does not seem to support the videos produced by iOS
*** https://github.com/mozilla/mp4parse-rust (MPL-2.0)
**** intentionally skips the creation time fields
*** Fork the mp4rs code and add the missing functionality
**** mp4parse-rust seems to support more types of boxes
**** it intentionally skips over the creation time fields
*** Find the MPEG-4 specification on the [[https://en.wikipedia.org/wiki/MPEG-4_Part_14][wikipedia]] page
*** Could just try invoking =ffprobe= and if that works, use it
**** if it fails for any reason, ignore it
**** https://github.com/nomalab/stainless-ffmpeg
** Frontend Rewrite
*** Use Dart and Flutter
*** Use Clean Architecture
**** define the features
***** browse
***** search
***** import
***** export
***** edit
*** TODO Move the files under =client/= to the root
*** TODO find out how to upload a file
**** https://rodolfohernan20.blogspot.com/2019/12/upload-files-to-server-with-flutter-web.html
**** example code: https://github.com/rjcalifornia/web_upload
*** TODO how to handle file drops
**** drop zone gist: https://gist.github.com/PlugFox/ffe83a91ce50f9c78a5b1d6674e36d1b
**** for now this is not so important, just use file selector a la =web_upload= example
*** TODO use docker container to build web assets
*** Thoughts on the design
**** browse and search
***** unify the two pages into one
***** with the "crane" like selectors, the search is just another row of inputs
***** that is, normally the second row is collapsed, but clicking a button expands it
***** the second row would have the date range, file name, and media type
**** quick import
***** drag/drop and/or file open to add lots of assets
***** immediately import everything to the backend
***** show progress and display thumbnails as assets are successfully imported
***** switch to the "recent imports" screen showing just these new assets
***** user selects multiple assets and applies tags and locations to them
***** click on an asset to enter a caption in place (without leaving the gallery view)
**** image gallery selectors
***** instead of showing all of the tags, years, locations at once
****** see the "crane" flutter gallery sample for the basic layout and appearance
****** use input fields with small icons on the left and drop-down button on the right
****** typing into the field will perform completion for tags, locations, years
****** clicking on the drop-down will offer selection of attributes
****** once entered or selected, input fields show active selectors
****** maybe have a small x to deactive active selectors
****** can also remove selectors by backspacing
**** image gallery display
***** show additional details on mouse hover
***** button in corner of thumbnail to select assets to edit, download, etc
**** asset detail page
***** seems popular to show the gallery items as small thumbnails along the top (horizontally scrollable)
***** have chevron buttons on both sides to navigate through gallery items (e.g. "lightbox")
**** timeline style display for all assets
***** without any selectors, just show most recent going back in time
*** ideas and widget usage
**** Look at the Flutter "Gallery" app ("crane") for a pretty example
***** gently rounded image corners
***** gallery background has rounded corners
***** pleasing captions
***** interesting not-quite-grid (column oriented) arrangement
***** selectors across the top
***** floating ~Back~ button at the bottom left
**** Consider how to have a "light" and "dark" mode
**** Look for the =video_player= web plugin for playing video in webui
**** use =RichText= widget to style the captions (e.g. make tags bold)
**** tags in caption could be "gesture sensitive" (i.e. clickable) to show assets with that tag
**** =ListView.builder= allows building list items on demand
***** c.f. https://medium.com/flutter-community/flutter-infinite-list-tutorial-with-flutter-bloc-2fc7a272ec67
**** =Image= has a loading builder for showing progress of network images
**** use =semanticLabel= on =Image= for accessibility
**** =Wrap= will do what =flex-flow: row wrap;= does in CSS
**** alternative to row wrapping would be columns of images
***** need to make the number of columns responsive to window width
**** =FutureBuilder= for showing things that load asynchronously
**** use =SliverAppBar= in place of =AppBar=, it will shrink when content is scrolled
***** could be a good way to keep controls above scrolling content
**** use =FadeInImage= to show a placeholder while loading a remote image
**** maybe use =Hero= to animate/transition from image gallery to a single image
***** click on item in a list/grid and it expands to the details page
**** can use =DataTable= to display labeled data (like asset details, metadata)
**** use pointer enter/exit events to start playing a video in place
*** TODO remove ReasonML related code and Node modules
**** should be nothing JavaScript/Node/Reason left at this point
**** =bsconfig.json=
**** =graphql_schema.json=
**** =gulpfile.js=
**** =node_modules=
**** =package.json=
**** =package-lock.json=
**** =public=
**** =src/*.re=
**** =lib/js=
**** =lib/bs=
**** update =.gitignore= and =.dockerignore=
** Performance
*** improve thumbnail caching support (=ETag= and =If-None-Match=)
**** need to include an etag and respond properly to if-none-match requests
**** create a =Thumbnail= type that implements =actix_web::Responder=
**** the =respond_to()= returns a future so can use async/await
**** in =respond_to()= can check the asset exists, check if the etag matches, generate thumbnail
**** respond with =StatusCode::NOT_MODIFIED= if not modified
**** respond with =OK= and the data if the etag does not match
**** c.f. https://github.com/actix/actix-web/blob/master/actix-files/src/named.rs
**** c.f. https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match
**** c.f. https://web.dev/http-cache/
*** measure and improve the thumbnail serving
**** consider caching in memory or on disk
**** maybe try using =magick-rust= to see if that is faster
**** measurements using =hey=
| conditions         | hey arguments | avg response time | payload size |
|--------------------+---------------+-------------------+--------------|
| rust debug initial | -n 5 -c 1     |            2.4346 |        50748 |
| node with caching  | -n 20 -c 1    |            0.0009 |         8932 |
| node with caching  | (default)     |            0.0309 |         8932 |
| node w/o caching   | (default)     |            0.1835 |         8932 |
| rust with 50% jpeg | -n 5 -c 1     |            2.4235 |         7076 |
| rust with 80% jpeg | -n 5 -c 1     |            2.4145 |        11793 |
| rust release 80%   | (default)     |            1.0994 |        11793 |
| rust release 75%   | (default)     |            1.0956 |        10263 |
*** consider if caching search results will improve responsiveness
**** could return a query code to the caller in search meta
**** caller returns that code in the next query to access the cache
**** in this way, the results for a particular query can be cached reliably
**** eventually cached search results need to be pruned
**** RocksDB by default has a block cache of 8mb in 16 shards of 512kb
**** also consider that any caching should live in the data source
*** consider if filtering can be done "in the database" somehow
**** database queries should probably take a filter closure
**** database functions iterate the results, applying the filter
**** the remaining results are then collecting into a vector
** Search Improvements
*** TODO Support advanced queries using Google-style operators
**** c.f. https://support.google.com/websearch/answer/2466433?hl=en
**** move perkeep style query support from mujina to tanuki
**** webui needs an "advanced" tab/link selector on the search page
**** =is:image= and similar to filter by media type
**** =with:<name>= to filter by people (need to know the people though)
**** =AND= and =OR= operators and grouping with parentheses
*** TODO Support searching for assets that have no tags at all
*** TODO Support searching for assets that have no location at all
*** TODO Support searching for assets that have no caption at all
*** TODO Support searching the caption text
**** likely would involve a full table scan
*** TODO Support wildcards in filename, mimetype (others?)
**** likely would involve a full table scan
** Data Format Support
*** Auto-populate missing fields on load
**** when loading an asset, detect missing data (e.g. no original time)
**** try reading the data from the asset and save to the asset record
**** in the future, as more data formats are supported, can fill in the blanks
*** Read other metadata formats
**** XMP
**** IPTC
*** TODO support HEIF images
**** https://crates.io/crates/libvips (MIT) reads/writes HEIF
***** this library easily crashes with a segmentation fault
**** https://github.com/oussama/libheif-rs (MIT)
**** https://crates.io/crates/kamadak-exif (BSD) reads metadata
*** TODO Detect time zone offset in EXIF data
According to Wikipedia the 2.31 version of EXIF will support time-zone
information. Eventually, the application should be able to detect this and
include it in the database records.

: There is no way to record time-zone information along with the time, thus
: rendering the stored time ambiguous. However, time-zone information have
: been introduced recently by Exif version 2.31 (July 2016). Related tags are:
: "OffsetTime", "OffsetTimeOriginal" and "OffsetTimeDigitized".

*** TODO Extract location information from images
**** write a data migration to process existing assets
**** existing location values should be stored in a "label" field
**** exact location information would be stored separate from label
*** TODO Read metadata from PDF files
**** probably has a creation date or some sort
*** TODO Show the =AAE= files as plain text (they are xml)
*** Reference
**** EXIF: https://www.media.mit.edu/pia/Research/deepview/exif.html
** Bulk edit
*** Short term solution akin to perkeep web interface
- [ ] Easy selection with hover checkbox button
  - Could use =svg= tag to render the button
  - See pexels.com in that it uses article tag, with nested img and button with nested svg
- [ ] When selections, filters panel changes to show available actions
- [ ] Actions include adding, deleting tags, setting location
  - This is basically a simplified bulk edit
- [ ] Use a prefix for the checksum values
*** Design bulk edit solution, probably similar to JIRA
- [ ] Access the bulk edit screen via a menu item
- [ ] Use search form
- [ ] Perform search, present results using "list" view
- [ ] Check off results as desired
- [ ] Next page presents several operations
  - [ ] add location
  - [ ] remove location
  - [ ] rename location
  - [ ] add a tag
  - [ ] remove a tag
  - [ ] rename a tag
  - [ ] set caption
  - [ ] change media type
** Documentation
*** Case Sensitivity
- Data is stored as entered (case preservative)
- Attribute lists are all lowercased
- Search is always case insensitive
*** Date/Time values
- Uses 24 hour clock, displays using local time zone, stored as UTC
- [[http://www.unicode.org/reports/tr35/tr35-43/tr35-dates.html#Date_Format_Patterns][Date_Format_Patterns]]
** Data Migrations
*** start planning on how to handle data(base) migrations
*** may be a good idea to introduce "metadata" records for assets
**** use a =metadata/= prefix with the id of the asset
**** can hold all sorts of additional information without cluttering the asset
**** should be some form of dictionary to keep things flexible
*** maintain an uber record for tracking database version
*** also the serde library is quite flexible with adding/removing fields
** Architecture Review
*** GraphQL server
**** consider https://github.com/async-graphql/async-graphql as alternative to juniper
***** handles multipart requests (file uploads)
***** provides actix-web integration
** Desktop app
*** Need setup for configuration system
**** properties
***** path for database files
***** path for where file uploads go temporarily
***** path for where assets are stored
**** default configuration setup at build-time
***** would be nice to have something like Dart's =environment_config=
****** could use =build.rs= to generate an environment config
******* then load that in =main.rs= to get everything into memory
***** https://github.com/andoriyu/uclicious (BSD)
***** https://github.com/mehcode/config-rs (MIT)
**** screen for configuring the settings
*** Showing the licenses/about dialog
**** c.f. "licenses" on https://flutter.dev/docs/resources/faq
** Mobile web support
*** Progressive Web App support in Flutter is coming
*** Use PWA to get app-like behavior on mobile devices
*** Look for package (like image_picker) that enables user to select photos to upload
** Mobile app
*** Use [[https://pub.dev/packages/image_picker][image_picker]] to allow user to select images from photo library
** Build Automation
*** For building the applications
*** Requirements
**** Consistent builds
**** Need this for building the application, not compiling code
***** dart, flutter, and rust/cargo all know how to compile code
***** need a process to assemble the application deliverable
**** Supports Rust, Dart, Flutter
**** Supports macOS, Windows?, Linux?
**** Likely need a build machine for each target (mac, windows, linux)
**** Contenders
****** https://bazel.build
****** https://please.build
****** https://jenkins.io
****** https://www.buildbot.net
**** Bazel
***** supports all major platforms
***** a very sophisticated replacement for =make=
***** not appropriate for replacing =cargo= or =flutter build=
***** dart: https://github.com/cbracken/rules_dart
***** rust: https://github.com/bazelbuild/rules_rust
***** rust: https://github.com/google/cargo-raze
****** tries to replace cargo to get benefits of bazel
** SCM
*** Consider if using GitLab (in a container) would be helpful
